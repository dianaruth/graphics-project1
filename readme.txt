COMP30019 Project 1
Terrain Generation Using the Diamond-Square Algorithm

Diana Ruth
Maile Naito

Terrain generation is done through the use of an empty Game Object and programmatically creating a mesh for the Game Object. A similar strategy as was used in tutorials was used in this project where the positions of vertices were calculated and added to an array, as well as the ordering of the vertices for rendering triangles in the correct order. Additionally, for each vertex added to the mesh, a color is added to the mesh's color array that changes based on the height of the vertex (green grass at low heights, white snow at larger heights, etc). The vertices, triangles, and color arrays were then added to the mesh and the mesh was applied to the empty Game Object to render the terrain. The heights of the vertices come from the heighmap generated using the Diamond-Square algorithm.

The entire terrain is limited to 128x128 vertices because Unity doesn't allow larger dimensions for a Game Object. The heightmap is a 2D array with a size that is a power of two minus one, which allows for the algorithm to divide the terrain smoothly for each recursive step. The heights (Y-values) for each vertex are generated by the Diamond-Square algorithm, and are added to the heightmap. The implementation of the Diamond-Square algorithm is adapted from the tutorial found at http://www.playfuljs.com/realistic-terrain-in-130-lines/, which is a JavaScript implementation of Diamond-Square. The corners of the heightmap are initialized to seed values, with this implementation setting two corners to a height of zero and two corners to half the maximum height. The DiamondSquare method is called recursively for sections of terrain until the input is less than one, signaling the end of the recursion. For each recursive step, SquareStep is called for each diamond and DiamondStep is called for each square. For SquareStep, the center of the diamond is set to the average of each corner point of the diamond plus a random value between 0 and 1. For DiamondStep, the center of the square is set to the average of each corner of the square plus a random value between 0 and 1. After experimenting with the random value added in DiamondStep and SquareStep, values larger than one caused the landscape to appear too sharp and therefore unrealistic. Whenever the algorithm attempts to access a corner that is outside the array, the value wraps around to the other side of the array so there are always four values to average. When the DiamondSquare recursive method is finished, the heightmap has completed and can be used to create the mesh, which is described in the above paragraph.

For the correct shading of a mesh, the custom shader needs the normal vector for each vertex. For the Phong-Illumination model,the color is approximated by the calculation of three components: a diffuse color, specular reflection, and an ambient component. These different surface properties are calculated using the equation used in Lab 5. Once the vertices and triangles were determined by the diamond-sqaure algorithm, the normals were recalculated using .RecalculateNormals() in order to store vertex normals of the mesh. The Phong Shader uses the normal vector of the surface, light vector(angle that it hits the surface), reflective vector(angle which light reflects off the surface), and viewer vector(angle of the perspective camera). The vertex is passed in with its world position, corresponding normal vector, and color, and then becomes transformed into a vertex with a vertex in relation to the camera, color, as well as a vertex and normal in world coordinates.

The sun is a simple sphere object with a yellow material added to it, and the sun is given an initial position at the origin and is set to rotate around a point halfway down the Z-axis so that the sun appears to rise and set. The directional light is then made a child of the sun so that it follows the position of the sun, and the light is set to always point to the middle of the terrain. The water is a simple plane with a blue material added to it that cuts through the bottom of the terrain to give the appearance of bodies of water on the terrain. The camera takes inputs from the A, W, S, and D keys and calculates a new position for the camera. If that new position is in the bounds of the terrain, then the new position is applied. The rotation of the camera is changed based on the mouse position and the input from the Q and E keys.